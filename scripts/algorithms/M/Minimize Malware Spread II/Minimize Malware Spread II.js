// Runtime: 241 ms (Top 30.00%) | Memory: 50.7 MB (Top 65.00%)
var minMalwareSpread = function(graph, initial) {
let n = graph.length
let AdjList = new Map();
let listFromGraph = (mat) => {// convert adj matrix to adj list
    for(let i=0; i<n; i++){
        AdjList[i] = [];
        for(let j=0; j<n; j++){
            if(mat[i][j] === 1 && i!==j){
                AdjList[i].push(j);
            }
        }
    }
}
listFromGraph(graph);
let visitedSet = new Set();//visited set, to manage the visited nodes & their count as they are unique
let dfs = (curr,node) => {// dfs helper, visit the graph assuming that node, given as 2nd parameter is deleted
    if(curr===node){
        return;
    }
    if(visitedSet.has(curr)){
        return;
    }
    visitedSet.add(curr);// size of visited shows how many nodes are visited/affected by the malware
    let neighbours = AdjList[curr];
    for(let i in neighbours){// visit all the neighbours
        dfs(neighbours[i],node);
    }
}
let MinSpread = n;// min index of node with max reduction in malware
let SpreadDist = n;// number of nodes affected by malware if MinSpread was deleted
for(let i=0; i<initial.length; i++){
    for(let j=0; j<initial.length; j++){// find the total nodes affected if ith node is removed
        dfs(initial[j],initial[i]);
    }
    if(SpreadDist == visitedSet.size){// to get min index but same impact
        MinSpread = Math.min(initial[i],MinSpread);
    }
    if(SpreadDist > visitedSet.size){// to get max impact
        MinSpread = initial[i];
        SpreadDist = visitedSet.size;
    }
    visitedSet.clear();// clear visited set for next index to be deleted
}
return MinSpread;
};