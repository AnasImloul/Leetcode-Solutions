// Runtime: 496 ms (Top 5.16%) | Memory: 71.7 MB (Top 6.98%)
class Solution {
public:
    void dfs(int i,int n,vector<bool> &visited,vector<int>&cur,map<int,int>& ind,int &cnt,map<int,vector<int> >&mp)
    {
        if(!visited[i])
        {
            visited[i]=true;
            cur.push_back(i);
            ind[i]=cnt;
            for(int j=0;j<mp[i].size();j++)
            {
                dfs(mp[i][j],n,visited,cur,ind,cnt,mp);
            }
        }
    }
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
         int n=graph.size();
         map<int,vector<int> > mp; //Adjacency list creation for the graph
         for(int i=0;i<n;i++)
         {
             for(int j=0;j<n;j++)
             {
                 if(i!=j && graph[i][j]==1)
                     mp[i].push_back(j);

             }
         }
        map<int,int> ind; // This map is for storing the component number to which a particular node belongs to
        vector<vector<int> > v; //Store all the connected components
        vector<bool> visited(n,false); //Visited array to keep track of the visited nodes
        int cnt=0;//Current component number
        for(int i=0;i<n;i++)
        {
            if(!visited[i])
            {
                vector<int> cur;
                dfs(i,n,visited,cur,ind,cnt,mp);//Dfs call for getting single components
                cnt++;
                v.push_back(cur);
            }
        }
    map<int,vector<int> > help; //This map tells that how many node that is present in inital vector are of same component
        for(int i=0;i<initial.size();i++)
        {
            int index=ind[initial[i]];
            help[index].push_back(initial[i]);
        }
        int sz=INT_MIN;
        int ans=n;//This loop is based on the logic described above
        for(auto it=help.begin();it!=help.end();it++)
        {
            if(help[it->first].size()==1)
            {
                int cover=v[it->first].size();
                if(cover>sz)
                {
                    sz=cover;
                    ans=help[it->first][0];
                }
                else if(cover==sz)
                {
                    if(help[it->first][0]<ans)
                        ans=help[it->first][0];
                }
            }
        }
        if(ans!=n)
            return ans;
        for(int i=0;i<initial.size();i++)
            ans=min(ans,initial[i]);
        return ans;

    }
};