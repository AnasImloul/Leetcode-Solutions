# Runtime: 1782 ms (Top 87.91%) | Memory: 16.6 MB (Top 91.21%)
class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        n = len(graph)
        uf = UnionFind(n)
        for i in range(n):
            for j in range(n):
                if graph[i][j]:
                    uf.union(i, j)

        max_remove = 0

        initial.sort()
        min_index = initial[0]
        for i in range(len(initial)):
            cur_remove = 0
            linked = False
            for j in range(len(initial)):
                if i == j: continue
                if uf.find(initial[i]) == uf.find(initial[j]):
                    linked = True
            if not linked:
                cur_remove = uf.rank[uf.find(initial[i])]
                if max_remove < cur_remove:
                    max_remove = cur_remove
                    min_index = initial[i]

        return min_index

class UnionFind:
    def __init__(self, size):
        self.parent = {}
        self.rank = {}
        for i in range(size):
            self.parent[i] = i
            self.rank[i] = 1

    def find(self, x):
        if x != self.parent[x]:
            x = self.find(self.parent[x])
        return x

    def union(self, x, y):
        px, py = self.find(x), self.find(y)
        if px == py: return
        if self.rank[px] >= self.rank[py]:
            self.parent[py] = px
            self.rank[px] += self.rank[py]
        else:
            self.parent[px] = py
            self.rank[py] += self.rank[px]